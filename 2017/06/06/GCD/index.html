<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>GCD | songbook</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="文章目录 GCD简介任务和队列GCD的使用步骤队列的创建方法任务的创建方法GCD的基本使用并发队列 + 同步执行并发队列 + 异步执行串行队列 + 同步执行串行队列 + 异步执行主队列 + 同步执行主队列 + 异步执行GCD线程之间的通讯GCD的其他方法GCD的栅栏方法dispatch_barrier_asyncGCD的延时执行方法dispatch_afterGCD的一次性代码(只执行一次)dis">
<meta property="og:type" content="article">
<meta property="og:title" content="GCD">
<meta property="og:url" content="http://yoursite.com/2017/06/06/GCD/index.html">
<meta property="og:site_name" content="songbook">
<meta property="og:description" content="文章目录 GCD简介任务和队列GCD的使用步骤队列的创建方法任务的创建方法GCD的基本使用并发队列 + 同步执行并发队列 + 异步执行串行队列 + 同步执行串行队列 + 异步执行主队列 + 同步执行主队列 + 异步执行GCD线程之间的通讯GCD的其他方法GCD的栅栏方法dispatch_barrier_asyncGCD的延时执行方法dispatch_afterGCD的一次性代码(只执行一次)dis">
<meta property="og:updated_time" content="2017-06-15T02:09:43.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="GCD">
<meta name="twitter:description" content="文章目录 GCD简介任务和队列GCD的使用步骤队列的创建方法任务的创建方法GCD的基本使用并发队列 + 同步执行并发队列 + 异步执行串行队列 + 同步执行串行队列 + 异步执行主队列 + 同步执行主队列 + 异步执行GCD线程之间的通讯GCD的其他方法GCD的栅栏方法dispatch_barrier_asyncGCD的延时执行方法dispatch_afterGCD的一次性代码(只执行一次)dis">
  
    <link rel="alternate" href="/atom.xml" title="songbook" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">songbook</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-GCD" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/06/GCD/" class="article-date">
  <time datetime="2017-06-06T05:33:32.000Z" itemprop="datePublished">2017-06-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      GCD
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>文章目录</p>
<p>GCD简介<br>任务和队列<br>GCD的使用步骤<br>队列的创建方法<br>任务的创建方法<br>GCD的基本使用<br>并发队列 + 同步执行<br>并发队列 + 异步执行<br>串行队列 + 同步执行<br>串行队列 + 异步执行<br>主队列 + 同步执行<br>主队列 + 异步执行<br>GCD线程之间的通讯<br>GCD的其他方法<br>GCD的栅栏方法dispatch_barrier_async<br>GCD的延时执行方法dispatch_after<br>GCD的一次性代码(只执行一次)dispatch_once<br>GCD的快速迭代方法dispatch_apply<br>GCD的队列组dispatch_group</p>
<ol>
<li>GCD简介</li>
</ol>
<p>什么是GCD呢？我们先来看看百度百科的解释简单了解下概念</p>
<p>引自百度百科<br>Grand Central Dispatch (GCD) 是Apple开发的一个多核编程的较新的解决方法。它主要用于优化应用程序以支持多核处理器以及其他对称多处理系统。它是一个在线程池模式的基础上执行的并行任务。在Mac OS X 10.6雪豹中首次推出，也可在IOS 4及以上版本使用。<br>为什么要用GCD呢？</p>
<p>因为GCD有很多好处啊，具体如下：</p>
<p>GCD可用于多核的并行运算<br>GCD会自动利用更多的CPU内核（比如双核、四核）<br>GCD会自动管理线程的生命周期（创建线程、调度任务、销毁线程）<br>程序员只需要告诉GCD想要执行什么任务，不需要编写任何线程管理代码<br>既然GCD有这么多的好处，那么下面我们就来系统的学习一下GCD的使用方法。</p>
<ol>
<li>任务和队列</li>
</ol>
<p>学习GCD之前，先来了解GCD中两个核心概念：任务和队列。</p>
<p>任务：就是执行操作的意思，换句话说就是你在线程中执行的那段代码。在GCD中是放在block中的。执行任务有两种方式：同步执行和异步执行。两者的主要区别是：是否具备开启新线程的能力。</p>
<p>同步执行（sync）：只能在当前线程中执行任务，不具备开启新线程的能力<br>异步执行（async）：可以在新的线程中执行任务，具备开启新线程的能力<br>队列：这里的队列指任务队列，即用来存放任务的队列。队列是一种特殊的线性表，采用FIFO（先进先出）的原则，即新任务总是被插入到队列的末尾，而读取任务的时候总是从队列的头部开始读取。每读取一个任务，则从队列中释放一个任务。在GCD中有两种队列：串行队列和并发队列。</p>
<p>并发队列（Concurrent Dispatch Queue）：可以让多个任务并发（同时）执行（自动开启多个线程同时执行任务）<br>并发功能只有在异步（dispatch_async）函数下才有效<br>串行队列（Serial Dispatch Queue）：让任务一个接着一个地执行（一个任务执行完毕后，再执行下一个任务）</p>
<ol>
<li>GCD的使用步骤</li>
</ol>
<p>GCD的使用步骤其实很简单，只有两步。</p>
<p>创建一个队列（串行队列或并发队列）<br>将任务添加到队列中，然后系统就会根据任务类型执行任务（同步执行或异步执行）<br>下边来看看队列的创建方法和任务的创建方法。</p>
<ol>
<li>队列的创建方法</li>
</ol>
<p>可以使用dispatch_queue_create来创建对象，需要传入两个参数，第一个参数表示队列的唯一标识符，用于DEBUG，可为空；第二个参数用来识别是串行队列还是并发队列。DISPATCH_QUEUE_SERIAL表示串行队列，DISPATCH_QUEUE_CONCURRENT表示并发队列。<br>// 串行队列的创建方法<br>dispatch_queue_t queue= dispatch_queue_create(“test.queue”, DISPATCH_QUEUE_SERIAL);<br>// 并发队列的创建方法<br>dispatch_queue_t queue= dispatch_queue_create(“test.queue”, DISPATCH_QUEUE_CONCURRENT);<br>对于并发队列，还可以使用dispatch_get_global_queue来创建全局并发队列。GCD默认提供了全局的并发队列，需要传入两个参数。第一个参数表示队列优先级，一般用DISPATCH_QUEUE_PRIORITY_DEFAULT。第二个参数暂时没用，用0即可。</p>
<ol>
<li>任务的创建方法<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 同步执行任务创建方法</span></div><div class="line"><span class="built_in">dispatch_sync</span>(queue, ^&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[<span class="built_in">NSThread</span> currentThread]);    <span class="comment">// 这里放任务代码</span></div><div class="line">&#125;);</div><div class="line"><span class="comment">// 异步执行任务创建方法</span></div><div class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[<span class="built_in">NSThread</span> currentThread]);    <span class="comment">// 这里放任务代码</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ol>
<p>虽然使用GCD只需两步，但是既然我们有两种队列，两种任务执行方式，那么我们就有了四种不同的组合方式。这四种不同的组合方式是</p>
<p>并发队列 + 同步执行<br>并发队列 + 异步执行<br>串行队列 + 同步执行<br>串行队列 + 异步执行<br>实际上，我们还有一种特殊队列是主队列，那样就有六种不同的组合方式了。</p>
<p>主队列 + 同步执行<br>主队列 + 异步执行<br>那么这几种不同组合方式各有什么区别呢，这里为了方便，先上结果，再来讲解。为图省事，直接查看表格结果，然后可以跳过 4. GCD的基本使用 了。</p>
<p>并发队列    串行队列    主队列<br>同步(sync)    没有开启新线程，串行执行任务    没有开启新线程，串行执行任务    没有开启新线程，串行执行任务<br>异步(async)    有开启新线程，并发执行任务    有开启新线程(1条)，串行执行任务    没有开启新线程，串行执行任务<br>下边我们来分别讲讲这几种不同的组合方式的使用方法。</p>
<ol>
<li>GCD的基本使用</li>
</ol>
<p>先来讲讲并发队列的两种使用方法。</p>
<ol>
<li>并发队列 + 同步执行</li>
</ol>
<p>不会开启新线程，执行完一个任务，再执行下一个任务<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>) syncConcurrent</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"syncConcurrent---begin"</span>);</div><div class="line"></div><div class="line">    <span class="built_in">dispatch_queue_t</span> queue= dispatch_queue_create(<span class="string">"test.queue"</span>, DISPATCH_QUEUE_CONCURRENT);</div><div class="line"></div><div class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"1------%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"2------%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"3------%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"syncConcurrent---end"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出结果：<br>2016-09-03 19:22:27.577 GCD[11557:1897538] syncConcurrent—begin<br>2016-09-03 19:22:27.578 GCD[11557:1897538] 1——<nsthread: 0x7f82a1d058b0="">{number = 1, name = main}<br>2016-09-03 19:22:27.578 GCD[11557:1897538] 1——<nsthread: 0x7f82a1d058b0="">{number = 1, name = main}<br>2016-09-03 19:22:27.578 GCD[11557:1897538] 2——<nsthread: 0x7f82a1d058b0="">{number = 1, name = main}<br>2016-09-03 19:22:27.579 GCD[11557:1897538] 2——<nsthread: 0x7f82a1d058b0="">{number = 1, name = main}<br>2016-09-03 19:22:27.579 GCD[11557:1897538] 3——<nsthread: 0x7f82a1d058b0="">{number = 1, name = main}<br>2016-09-03 19:22:27.579 GCD[11557:1897538] 3——<nsthread: 0x7f82a1d058b0="">{number = 1, name = main}<br>2016-09-03 19:22:27.579 GCD[11557:1897538] syncConcurrent—end<br>从并发队列 + 同步执行中可以看到，所有任务都是在主线程中执行的。由于只有一个线程，所以任务只能一个一个执行。<br>同时我们还可以看到，所有任务都在打印的syncConcurrent—begin和syncConcurrent—end之间，这说明任务是添加到队列中马上执行的。</nsthread:></nsthread:></nsthread:></nsthread:></nsthread:></nsthread:></p>
<ol>
<li>并发队列 + 异步执行</li>
</ol>
<p>可同时开启多线程，任务交替执行<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>) asyncConcurrent</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"asyncConcurrent---begin"</span>);</div><div class="line"></div><div class="line">    <span class="built_in">dispatch_queue_t</span> queue= dispatch_queue_create(<span class="string">"test.queue"</span>, DISPATCH_QUEUE_CONCURRENT);</div><div class="line"></div><div class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"1------%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"2------%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"3------%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"asyncConcurrent---end"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出结果：<br>2016-09-03 19:27:31.503 GCD[11595:1901548] asyncConcurrent—begin<br>2016-09-03 19:27:31.504 GCD[11595:1901548] asyncConcurrent—end<br>2016-09-03 19:27:31.504 GCD[11595:1901626] 1——<nsthread: 0x7f8309c22080="">{number = 2, name = (null)}<br>2016-09-03 19:27:31.504 GCD[11595:1901625] 2——<nsthread: 0x7f8309f0b790="">{number = 4, name = (null)}<br>2016-09-03 19:27:31.504 GCD[11595:1901855] 3——<nsthread: 0x7f8309e1a950="">{number = 3, name = (null)}<br>2016-09-03 19:27:31.504 GCD[11595:1901626] 1——<nsthread: 0x7f8309c22080="">{number = 2, name = (null)}<br>2016-09-03 19:27:31.504 GCD[11595:1901625] 2——<nsthread: 0x7f8309f0b790="">{number = 4, name = (null)}<br>2016-09-03 19:27:31.505 GCD[11595:1901855] 3——<nsthread: 0x7f8309e1a950="">{number = 3, name = (null)}<br>在并发队列 + 异步执行中可以看出，除了主线程，又开启了3个线程，并且任务是交替着同时执行的。<br>另一方面可以看出，所有任务是在打印的syncConcurrent—begin和syncConcurrent—end之后才开始执行的。说明任务不是马上执行，而是将所有任务添加到队列之后才开始异步执行。<br>接下来再来讲讲串行队列的执行方法。</nsthread:></nsthread:></nsthread:></nsthread:></nsthread:></nsthread:></p>
<ol>
<li>串行队列 + 同步执行</li>
</ol>
<p>不会开启新线程，在当前线程执行任务。任务是串行的，执行完一个任务，再执行下一个任务<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>) syncSerial</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"syncSerial---begin"</span>);</div><div class="line"></div><div class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"test.queue"</span>, DISPATCH_QUEUE_SERIAL);</div><div class="line"></div><div class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"1------%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</div><div class="line">        &#125;</div><div class="line">    &#125;);    </div><div class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"2------%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"3------%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"syncSerial---end"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出结果为：<br>2016-09-03 19:29:00.066 GCD[11622:1903904] syncSerial—begin<br>2016-09-03 19:29:00.067 GCD[11622:1903904] 1——<nsthread: 0x7fa2e9f00980="">{number = 1, name = main}<br>2016-09-03 19:29:00.067 GCD[11622:1903904] 1——<nsthread: 0x7fa2e9f00980="">{number = 1, name = main}<br>2016-09-03 19:29:00.067 GCD[11622:1903904] 2——<nsthread: 0x7fa2e9f00980="">{number = 1, name = main}<br>2016-09-03 19:29:00.067 GCD[11622:1903904] 2——<nsthread: 0x7fa2e9f00980="">{number = 1, name = main}<br>2016-09-03 19:29:00.067 GCD[11622:1903904] 3——<nsthread: 0x7fa2e9f00980="">{number = 1, name = main}<br>2016-09-03 19:29:00.068 GCD[11622:1903904] 3——<nsthread: 0x7fa2e9f00980="">{number = 1, name = main}<br>2016-09-03 19:29:00.068 GCD[11622:1903904] syncSerial—end<br>在串行队列 + 同步执行可以看到，所有任务都是在主线程中执行的，并没有开启新的线程。而且由于串行队列，所以按顺序一个一个执行。<br>同时我们还可以看到，所有任务都在打印的syncConcurrent—begin和syncConcurrent—end之间，这说明任务是添加到队列中马上执行的。</nsthread:></nsthread:></nsthread:></nsthread:></nsthread:></nsthread:></p>
<ol>
<li>串行队列 + 异步执行</li>
</ol>
<p>会开启新线程，但是因为任务是串行的，执行完一个任务，再执行下一个任务<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>) asyncSerial</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"asyncSerial---begin"</span>);</div><div class="line"></div><div class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"test.queue"</span>, DISPATCH_QUEUE_SERIAL);</div><div class="line"></div><div class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"1------%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</div><div class="line">        &#125;</div><div class="line">    &#125;);    </div><div class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"2------%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"3------%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"asyncSerial---end"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出结果为：<br>2016-09-03 19:30:08.363 GCD[11648:1905817] asyncSerial—begin<br>2016-09-03 19:30:08.364 GCD[11648:1905817] asyncSerial—end<br>2016-09-03 19:30:08.364 GCD[11648:1905895] 1——<nsthread: 0x7fb548c0e390="">{number = 2, name = (null)}<br>2016-09-03 19:30:08.364 GCD[11648:1905895] 1——<nsthread: 0x7fb548c0e390="">{number = 2, name = (null)}<br>2016-09-03 19:30:08.364 GCD[11648:1905895] 2——<nsthread: 0x7fb548c0e390="">{number = 2, name = (null)}<br>2016-09-03 19:30:08.364 GCD[11648:1905895] 2——<nsthread: 0x7fb548c0e390="">{number = 2, name = (null)}<br>2016-09-03 19:30:08.365 GCD[11648:1905895] 3——<nsthread: 0x7fb548c0e390="">{number = 2, name = (null)}<br>2016-09-03 19:30:08.365 GCD[11648:1905895] 3——<nsthread: 0x7fb548c0e390="">{number = 2, name = (null)}<br>在串行队列 + 异步执行可以看到，开启了一条新线程，但是任务还是串行，所以任务是一个一个执行。<br>另一方面可以看出，所有任务是在打印的syncConcurrent—begin和syncConcurrent—end之后才开始执行的。说明任务不是马上执行，而是将所有任务添加到队列之后才开始同步执行。<br>下边讲讲刚才我们提到过的特殊队列——主队列。</nsthread:></nsthread:></nsthread:></nsthread:></nsthread:></nsthread:></p>
<p>主队列：GCD自带的一种特殊的串行队列<br>所有放在主队列中的任务，都会放到主线程中执行<br>可使用dispatch_get_main_queue()获得主队列<br>我们再来看看主队列的两种组合方式。</p>
<ol>
<li>主队列 + 同步执行</li>
</ol>
<p>互等卡住不可行(在主线程中调用)<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)syncMain</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"syncMain---begin"</span>);</div><div class="line"></div><div class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_main_queue();</div><div class="line"></div><div class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"1------%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"2------%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"3------%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</div><div class="line">        &#125;</div><div class="line">    &#125;);   </div><div class="line"></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"syncMain---end"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出结果<br>2016-09-03 19:32:15.356 GCD[11670:1908306] syncMain—begin<br>这时候，我们惊奇的发现，在主线程中使用主队列 + 同步执行，任务不再执行了，而且syncMain—end也没有打印。这是为什么呢？</p>
<p>这是因为我们在主线程中执行这段代码。我们把任务放到了主队列中，也就是放到了主线程的队列中。而同步执行有个特点，就是对于任务是立马执行的。那么当我们把第一个任务放进主队列中，它就会立马执行。但是主线程现在正在处理syncMain方法，所以任务需要等syncMain执行完才能执行。而syncMain执行到第一个任务的时候，又要等第一个任务执行完才能往下执行第二个和第三个任务。</p>
<p>那么，现在的情况就是syncMain方法和第一个任务都在等对方执行完毕。这样大家互相等待，所以就卡住了，所以我们的任务执行不了，而且syncMain—end也没有打印。</p>
<p>要是如果不再主线程中调用，而在其他线程中调用会如何呢？</p>
<p>不会开启新线程，执行完一个任务，再执行下一个任务（在其他线程中调用）<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"test.queue"</span>, DISPATCH_QUEUE_CONCURRENT);</div><div class="line"></div><div class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">    [<span class="keyword">self</span> syncMain];</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>输出结果：<br>2016-09-03 19:32:45.496 GCD[11686:1909617] syncMain—begin<br>2016-09-03 19:32:45.497 GCD[11686:1909374] 1——<nsthread: 0x7faef2f01600="">{number = 1, name = main}<br>2016-09-03 19:32:45.498 GCD[11686:1909374] 1——<nsthread: 0x7faef2f01600="">{number = 1, name = main}<br>2016-09-03 19:32:45.498 GCD[11686:1909374] 2——<nsthread: 0x7faef2f01600="">{number = 1, name = main}<br>2016-09-03 19:32:45.498 GCD[11686:1909374] 2——<nsthread: 0x7faef2f01600="">{number = 1, name = main}<br>2016-09-03 19:32:45.499 GCD[11686:1909374] 3——<nsthread: 0x7faef2f01600="">{number = 1, name = main}<br>2016-09-03 19:32:45.499 GCD[11686:1909374] 3——<nsthread: 0x7faef2f01600="">{number = 1, name = main}<br>2016-09-03 19:32:45.499 GCD[11686:1909617] syncMain—end<br>在其他线程中使用主队列 + 同步执行可看到：所有任务都是在主线程中执行的，并没有开启新的线程。而且由于主队列是串行队列，所以按顺序一个一个执行。<br>同时我们还可以看到，所有任务都在打印的syncConcurrent—begin和syncConcurrent—end之间，这说明任务是添加到队列中马上执行的。</nsthread:></nsthread:></nsthread:></nsthread:></nsthread:></nsthread:></p>
<ol>
<li>主队列 + 异步执行</li>
</ol>
<p>只在主线程中执行任务，执行完一个任务，再执行下一个任务<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)asyncMain</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"asyncMain---begin"</span>);</div><div class="line"></div><div class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_main_queue();</div><div class="line"></div><div class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"1------%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</div><div class="line">        &#125;</div><div class="line">    &#125;);    </div><div class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"2------%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"3------%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</div><div class="line">        &#125;</div><div class="line">    &#125;);  </div><div class="line"></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"asyncMain---end"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出结果：<br>2016-09-03 19:33:54.995 GCD[11706:1911313] asyncMain—begin<br>2016-09-03 19:33:54.996 GCD[11706:1911313] asyncMain—end<br>2016-09-03 19:33:54.996 GCD[11706:1911313] 1——<nsthread: 0x7fb623d015e0="">{number = 1, name = main}<br>2016-09-03 19:33:54.997 GCD[11706:1911313] 1——<nsthread: 0x7fb623d015e0="">{number = 1, name = main}<br>2016-09-03 19:33:54.997 GCD[11706:1911313] 2——<nsthread: 0x7fb623d015e0="">{number = 1, name = main}<br>2016-09-03 19:33:54.997 GCD[11706:1911313] 2——<nsthread: 0x7fb623d015e0="">{number = 1, name = main}<br>2016-09-03 19:33:54.997 GCD[11706:1911313] 3——<nsthread: 0x7fb623d015e0="">{number = 1, name = main}<br>2016-09-03 19:33:54.997 GCD[11706:1911313] 3——<nsthread: 0x7fb623d015e0="">{number = 1, name = main}<br>我们发现所有任务都在主线程中，虽然是异步执行，具备开启线程的能力，但因为是主队列，所以所有任务都在主线程中，并且一个接一个执行。<br>另一方面可以看出，所有任务是在打印的syncConcurrent—begin和syncConcurrent—end之后才开始执行的。说明任务不是马上执行，而是将所有任务添加到队列之后才开始同步执行。<br>弄懂了难理解、绕来绕去的队列+任务之后，我们来学习一个简单的东西——GCD线程之间的通讯。</nsthread:></nsthread:></nsthread:></nsthread:></nsthread:></nsthread:></p>
<ol>
<li>GCD线程之间的通讯</li>
</ol>
<p>在iOS开发过程中，我们一般在主线程里边进行UI刷新，例如：点击、滚动、拖拽等事件。我们通常把一些耗时的操作放在其他线程，比如说图片下载、文件上传等耗时操作。而当我们有时候在其他线程完成了耗时操作时，需要回到主线程，那么就用到了线程之间的通讯。<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"1------%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 回到主线程</span></div><div class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"2-------%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>输出结果：<br>2016-09-03 19:34:59.165 GCD[11728:1913039] 1——<nsthread: 0x7f8319c06820="">{number = 2, name = (null)}<br>2016-09-03 19:34:59.166 GCD[11728:1913039] 1——<nsthread: 0x7f8319c06820="">{number = 2, name = (null)}<br>2016-09-03 19:34:59.166 GCD[11728:1912961] 2——-<nsthread: 0x7f8319e00560="">{number = 1, name = main}<br>可以看到在其他线程中先执行操作，执行完了之后回到主线程执行主线程的相应操作。</nsthread:></nsthread:></nsthread:></p>
<ol>
<li><p>GCD的其他方法</p>
</li>
<li><p>GCD的栅栏方法 dispatch_barrier_async</p>
</li>
</ol>
<p>我们有时需要异步执行两组操作，而且第一组操作执行完之后，才能开始执行第二组操作。这样我们就需要一个相当于栅栏一样的一个方法将两组异步执行的操作组给分割起来，当然这里的操作组里可以包含一个或多个任务。这就需要用到dispatch_barrier_async方法在两个操作组间形成栅栏。<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)barrier</div><div class="line">&#123;</div><div class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"12312312"</span>, DISPATCH_QUEUE_CONCURRENT);</div><div class="line"></div><div class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"----1-----%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"----2-----%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    dispatch_barrier_async(queue, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"----barrier-----%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"----3-----%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"----4-----%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出结果：<br>2016-09-03 19:35:51.271 GCD[11750:1914724] —-1—–<nsthread: 0x7fb1826047b0="">{number = 2, name = (null)}<br>2016-09-03 19:35:51.272 GCD[11750:1914722] —-2—–<nsthread: 0x7fb182423fd0="">{number = 3, name = (null)}<br>2016-09-03 19:35:51.272 GCD[11750:1914722] —-barrier—–<nsthread: 0x7fb182423fd0="">{number = 3, name = (null)}<br>2016-09-03 19:35:51.273 GCD[11750:1914722] —-3—–<nsthread: 0x7fb182423fd0="">{number = 3, name = (null)}<br>2016-09-03 19:35:51.273 GCD[11750:1914724] —-4—–<nsthread: 0x7fb1826047b0="">{number = 2, name = (null)}<br>可以看出在执行完栅栏前面的操作之后，才执行栅栏操作，最后再执行栅栏后边的操作。</nsthread:></nsthread:></nsthread:></nsthread:></nsthread:></p>
<ol>
<li>GCD的延时执行方法 dispatch_after</li>
</ol>
<p>当我们需要延迟执行一段代码时，就需要用到GCD的dispatch_after方法。<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">2.0</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</div><div class="line">    <span class="comment">// 2秒后异步执行这里的代码...</span></div><div class="line">   <span class="built_in">NSLog</span>(<span class="string">@"run-----"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<ol>
<li>GCD的一次性代码(只执行一次) dispatch_once</li>
</ol>
<p>我们在创建单例、或者有整个程序运行过程中只执行一次的代码时，我们就用到了GCD的dispatch_once方法。使用dispatch_once函数能保证某段代码在程序运行过程中只被执行1次。<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</div><div class="line"><span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</div><div class="line">    <span class="comment">// 只执行1次的代码(这里面默认是线程安全的)</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<ol>
<li>GCD的快速迭代方法 dispatch_apply</li>
</ol>
<p>通常我们会用for循环遍历，但是GCD给我们提供了快速迭代的方法dispatch_apply，使我们可以同时遍历。比如说遍历0~5这6个数字，for循环的做法是每次取出一个元素，逐个遍历。dispatch_apply可以同时遍历多个数字。<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</div><div class="line"></div><div class="line">dispatch_apply(<span class="number">6</span>, queue, ^(size_t index) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%zd------%@"</span>,index, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>输出结果：<br>2016-09-03 19:37:02.250 GCD[11764:1915764] 1——<nsthread: 0x7fac9a7029e0="">{number = 1, name = main}<br>2016-09-03 19:37:02.250 GCD[11764:1915885] 0——<nsthread: 0x7fac9a614bd0="">{number = 2, name = (null)}<br>2016-09-03 19:37:02.250 GCD[11764:1915886] 2——<nsthread: 0x7fac9a542b20="">{number = 3, name = (null)}<br>2016-09-03 19:37:02.251 GCD[11764:1915764] 4——<nsthread: 0x7fac9a7029e0="">{number = 1, name = main}<br>2016-09-03 19:37:02.250 GCD[11764:1915884] 3——<nsthread: 0x7fac9a76ca10="">{number = 4, name = (null)}<br>2016-09-03 19:37:02.251 GCD[11764:1915885] 5——<nsthread: 0x7fac9a614bd0="">{number = 2, name = (null)}<br>从输出结果中前边的时间中可以看出，几乎是同时遍历的。</nsthread:></nsthread:></nsthread:></nsthread:></nsthread:></nsthread:></p>
<ol>
<li>GCD的队列组 dispatch_group</li>
</ol>
<p>有时候我们会有这样的需求：分别异步执行2个耗时操作，然后当2个耗时操作都执行完毕后再回到主线程执行操作。这时候我们可以用到GCD的队列组。<br>我们可以先把任务放到队列中，然后将队列放入队列组中。<br>调用队列组的dispatch_group_notify回到主线程执行操作。<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">dispatch_group_t group =  dispatch_group_create();</div><div class="line"></div><div class="line">dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</div><div class="line">    <span class="comment">// 执行1个耗时的异步操作</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line">dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</div><div class="line">    <span class="comment">// 执行1个耗时的异步操作</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</div><div class="line">    <span class="comment">// 等前面的异步操作都执行完毕后，回到主线程...</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<hr>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)Dispatch_Group &#123;</div><div class="line">    <span class="built_in">dispatch_queue_t</span> quene = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</div><div class="line">    dispatch_group_t group = dispatch_group_create();</div><div class="line">    </div><div class="line">    <span class="comment">//出于其他线程中</span></div><div class="line">    dispatch_group_enter(group);</div><div class="line">    </div><div class="line">    dispatch_group_async(group, quene, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"block0"</span>);</div><div class="line">        dispatch_group_leave(group);</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    dispatch_group_enter(group);</div><div class="line">    dispatch_group_async(group, quene, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"block1"</span>);</div><div class="line">        dispatch_group_leave(group);</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    <span class="comment">//输出不定</span></div><div class="line">    <span class="comment">//第一个参数指定为要监听的group - 在group中的任务都执行完成后调用</span></div><div class="line">    dispatch_group_notify(group, quene, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"done"</span>);</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    dispatch_group_async(group, quene, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"block2"</span>);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)Dispatch_Apply</div><div class="line">&#123;</div><div class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</div><div class="line">    dispatch_apply(<span class="number">10</span>, queue, ^(size_t index) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"current thread is %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%zu"</span>,index);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)Dispatch_OnceCode &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"dispatch_once执行之前"</span>);</div><div class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</div><div class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"执行一次？"</span>);</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"dispath_once执行之后"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)Dispatch_AfterCode &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"dispatch_afterz执行之前"</span>);</div><div class="line">    <span class="comment">//延迟最起码3秒以上，因为这里block任务会在3秒后提交到主队列，block后面的代码先执行</span></div><div class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">3</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"执行block代码"</span>);</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"dispathch_alfter执行之后"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#pragma mark - Dispatchbarrier</span></div><div class="line"><span class="comment">//dispatch_barrier_sync在并发队列中</span></div><div class="line">- (<span class="keyword">void</span>)Dispatch_barrier_sync_inConcurrent_queueFunc &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"1----block执行之前-------"</span>);</div><div class="line">    </div><div class="line">    <span class="built_in">dispatch_queue_t</span> concurrent_queue = dispatch_queue_create(<span class="string">"dee"</span>, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index&lt;<span class="number">5</span>; index++) &#123;</div><div class="line">        <span class="built_in">dispatch_async</span>(concurrent_queue, ^&#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"index is %d"</span>,index);</div><div class="line">              <span class="built_in">NSLog</span>(<span class="string">@"current thread is %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    dispatch_barrier_sync(concurrent_queue, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"barrier_sync Action...."</span>);</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"current thread is %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">5</span>; index&lt;<span class="number">10</span>; index++) &#123;</div><div class="line">        <span class="built_in">dispatch_async</span>(concurrent_queue, ^&#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"index is %d"</span>,index);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"4----block完成之后-------"</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">//dispatch_barrier_async在并发队列中</span></div><div class="line">- (<span class="keyword">void</span>)Dispatch_barrier_async_inConcurrent_queueFunc &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"1----block执行之前-------"</span>);</div><div class="line">    </div><div class="line">    <span class="built_in">dispatch_queue_t</span> concurrent_queue = dispatch_queue_create(<span class="string">"dee"</span>, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index&lt;<span class="number">5</span>; index++) &#123;</div><div class="line">        <span class="built_in">dispatch_async</span>(concurrent_queue, ^&#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"index is %d"</span>,index);</div><div class="line">              <span class="built_in">NSLog</span>(<span class="string">@"current thread is %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    dispatch_barrier_async(concurrent_queue, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"barrier_async Action...."</span>);</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"current thread is %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">5</span>; index&lt;<span class="number">10</span>; index++) &#123;</div><div class="line">        <span class="built_in">dispatch_async</span>(concurrent_queue, ^&#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"index is %d"</span>,index);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"4----block完成之后-------"</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">//dispatch_barrier_sync在串行队列中</span></div><div class="line">- (<span class="keyword">void</span>)Dispatch_barrier_sync_inSerial_queueFunc &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"1----block执行之前-------"</span>);</div><div class="line">    </div><div class="line">    <span class="built_in">dispatch_queue_t</span> serial_queue = dispatch_queue_create(<span class="string">"dee"</span>, DISPATCH_QUEUE_SERIAL);</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index&lt;<span class="number">5</span>; index++) &#123;</div><div class="line">        <span class="built_in">dispatch_async</span>(serial_queue, ^&#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"index is %d"</span>,index);</div><div class="line">              <span class="built_in">NSLog</span>(<span class="string">@"current thread is %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    dispatch_barrier_sync(serial_queue, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"barrier_sync Action...."</span>);</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"current thread is %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">5</span>; index&lt;<span class="number">10</span>; index++) &#123;</div><div class="line">        <span class="built_in">dispatch_async</span>(serial_queue, ^&#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"index is %d"</span>,index);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"4----block完成之后-------"</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">//dispatch_barrier_async在串行队列中</span></div><div class="line">- (<span class="keyword">void</span>)Dispatch_barrier_async_inSerial_queueFunc &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"1----block执行之前-------"</span>);</div><div class="line">    </div><div class="line">    <span class="built_in">dispatch_queue_t</span> serial_queue = dispatch_queue_create(<span class="string">"dee"</span>, DISPATCH_QUEUE_SERIAL);</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index&lt;<span class="number">5</span>; index++) &#123;</div><div class="line">        <span class="built_in">dispatch_async</span>(serial_queue, ^&#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"index is %d"</span>,index);</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@" ------ %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    dispatch_barrier_async(serial_queue, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"barrier_async Action...."</span>);</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"current thread is %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">5</span>; index&lt;<span class="number">10</span>; index++) &#123;</div><div class="line">        <span class="built_in">dispatch_async</span>(serial_queue, ^&#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"index is %d"</span>,index);</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@" ------ %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"4----block完成之后-------"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#pragma mark - 串行 和 并发</span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)Serial_AsyncFunc &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"1----block执行之前-------"</span>);</div><div class="line">    <span class="built_in">dispatch_queue_t</span> serail_queue = dispatch_queue_create(<span class="string">"dee"</span>, DISPATCH_QUEUE_SERIAL);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index&lt;<span class="number">10</span>; index++) &#123;</div><div class="line">        <span class="built_in">dispatch_async</span>(serail_queue, ^&#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"current thread is %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"4----block完成之后-------"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)Concurrent_AsyncFunc &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"1----block执行之前-------"</span>);</div><div class="line">    <span class="built_in">dispatch_queue_t</span> concurrent_queue = dispatch_queue_create(<span class="string">"dee"</span>, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index&lt;<span class="number">10</span>; index++) &#123;</div><div class="line">        <span class="built_in">dispatch_async</span>(concurrent_queue, ^&#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"current thread is %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"4----block完成之后-------"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)Searil_SyncFunc &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"1----block执行之前-------"</span>);</div><div class="line">    <span class="built_in">dispatch_queue_t</span> serail_queue = dispatch_queue_create(<span class="string">"dee"</span>, DISPATCH_QUEUE_SERIAL);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index&lt;<span class="number">10</span>; index++) &#123;</div><div class="line">        <span class="built_in">dispatch_sync</span>(serail_queue, ^&#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"current thread is %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"4----block完成之后-------"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)Concurrent_SyncFunc &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"1----block执行之前-------"</span>);</div><div class="line">    <span class="built_in">dispatch_queue_t</span> serail_queue = dispatch_queue_create(<span class="string">"dee"</span>, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index&lt;<span class="number">10</span>; index++) &#123;</div><div class="line">        <span class="built_in">dispatch_sync</span>(serail_queue, ^&#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"current thread is %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"4----block完成之后-------"</span>);</div><div class="line">&#125;</div><div class="line"><span class="meta">#pragma mark - 同步 和 异步</span></div><div class="line"><span class="comment">//同步分发 - 串行队列</span></div><div class="line">- (<span class="keyword">void</span>)Dispatch_SyncCode &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"1----block执行之前----🙋---"</span>);</div><div class="line">    <span class="built_in">dispatch_queue_t</span> seril_queue = dispatch_queue_create(<span class="string">"dee"</span>, DISPATCH_QUEUE_SERIAL);</div><div class="line">    </div><div class="line">    <span class="built_in">dispatch_sync</span>(seril_queue, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"2----执行中..."</span>);</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"current thread is %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2.0</span>];</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"3----执行结束..."</span>);</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"4----block完成之后-------"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//异步分发 - 并发队列</span></div><div class="line">- (<span class="keyword">void</span>)Dispatch_AsyncCode &#123;</div><div class="line"></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"1----block执行之前-------"</span>);</div><div class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"2----执行中..."</span>);</div><div class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2.0</span>];</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"3----执行结束..."</span>);</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"4----block完成之后-------"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//异步分发 - 串行队列</span></div><div class="line">- (<span class="keyword">void</span>)Dispatch_AsynCode1 &#123;</div><div class="line">    </div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"1----block执行之前-------"</span>);</div><div class="line">    <span class="built_in">dispatch_queue_t</span> seril_queue = dispatch_queue_create(<span class="string">"dee"</span>, DISPATCH_QUEUE_SERIAL);</div><div class="line">    <span class="built_in">dispatch_async</span>(seril_queue, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"2----执行中..."</span>);</div><div class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2.0</span>];</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"3----执行结束..."</span>);</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"4----block完成之后-------"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//同步分发 - 并发队列</span></div><div class="line">- (<span class="keyword">void</span>)Dispatch_SyncCode1 &#123;</div><div class="line">    </div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"1----block执行之前-------"</span>);</div><div class="line">    </div><div class="line">    <span class="built_in">dispatch_sync</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"2----执行中..."</span>);</div><div class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2.0</span>];</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"3----执行结束..."</span>);</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"4----block完成之后-------"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/06/06/GCD/" data-id="cj3y09o7s0002wpfyclr8elda" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/06/07/OS中break、continue、return三者的区别/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          OS中break、continue、return三者的区别
        
      </div>
    </a>
  
  
    <a href="/2017/06/05/Foundation/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Foundation</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/06/14/沙盒文件以及沙盒文件路径、和本地存储/">沙盒文件以及沙盒文件路径、和本地存储</a>
          </li>
        
          <li>
            <a href="/2017/06/13/NSArray的基本使用/">NSArray的基本使用</a>
          </li>
        
          <li>
            <a href="/2017/06/13/Programmer-English-Vocabulary/">Programmer English Vocabulary</a>
          </li>
        
          <li>
            <a href="/2017/06/07/iOS-UIKit框架/">iOS UIKit框架</a>
          </li>
        
          <li>
            <a href="/2017/06/07/Technology-blog/">Technology blog</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 songbo<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>